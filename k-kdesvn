#!/usr/bin/env -S deno run -A
// -*- mode: typescript; -*-
/** Commands for managing a local kdesvn repository checkout. */
// vim: ft=typescript

import {
  mkdirSync,
  writeFileSync,
  readFileSync,
  existsSync,
  symlinkSync,
} from "node:fs";
import { spawn } from "node:child_process";
import * as process from "node:process";
import path from "node:path";

// Fancy name for "every combination" that Shell exposes in the {a,b}{c,d}
// wildcard syntax.
import fastCartesian from "npm:fast-cartesian";
import { Chalk } from "npm:chalk";

import { program, Option } from "npm:@commander-js/extra-typings";

const chalk = new Chalk({
  // Force colors on even if we're piping to another program
  // The main program we're piping to is `less -R`. We just want paging for the
  // same output we'd get in the terminal normally.
  level: 3,
});

import { link } from "npm:ansi-escapes";

import {
  parseCommaSeparated,
  formatISO,
  fetchLogEntries,
  ArgLogMsgFormat,
  ArgLogSort,
} from "./utils.ts";
import { runcmd } from "./runcmd.ts";

program.description(`Commands for managing a local checkout of an svn repository with git.

The Git repository is only here locally, and is used for local diff checking.`);

/**
 * Check out `languages` for the current repository.
 * Assumes current directory is the top level of the svn working copy.
 */
function checkoutLanguages(languages: string[]) {
  // Valid team names. We read them here because they've only become
  // available here.
  const teamnames = readFileSync(`trunk/l10n-kf6/teamnames`, {
    encoding: "utf-8",
  })
    .split("\n")
    .map((x) => {
      const trimmed = x.trim();
      return trimmed.length === 0 || trimmed.startsWith("#")
        ? undefined
        : trimmed.split("=")[0];
    })
    .filter((x) => typeof x === "string");
  const invalidLanguages = [
    ...new Set(languages).difference(new Set(...teamnames)),
  ];
  if (invalidLanguages.length > 0) {
    console.log(
      invalidLanguages.length === 1
        ? `Invalid language code provided: ${invalidLanguages}`
        : `Invalid language codes provided: ${invalidLanguages}`,
    );
    process.exit(1);
  }
  console.log(`Setting up language paths...`);
  runcmd()(
    "svn update --set-depth infinity",
    ...fastCartesian([
      ["trunk", "branches/stable"],
      ["l10n-kf5", "l10n-kf6"],
      languages,
    ]).map((a) => a.join("/")),
  );
}

/**
 * Checkout the KDE SVN repository to `dir` then set it up.
 * `readonly`: whether to clone from the readonly repo or not
 * `languages`: set the repository up for these languages
 * HACK: this will leave process.chdir within `dir`.
 */
function setupSvnCheckout(
  dir: string,
  readonly: boolean | undefined,
  languages: string[],
) {
  const repoUrl = readonly
    ? "svn://anonsvn.kde.org/home/kde/"
    : "svn+ssh://svn@svn.kde.org/home/kde/";
  console.log(
    readonly
      ? `Checking out the read-only KDE subversion repository into ${dir}...`
      : `Checking out the read-write KDE subversion repository into ${dir}...`,
  );
  const $$ = runcmd({ showcmd: true });
  $$("svn checkout --depth=empty", repoUrl, dir);
  process.chdir(dir);
  // The goal:
  //   svn update --set-depth infinity branches/stable/l10n-kf{5,6}/{...}
  //   svn update --set-depth infinity trunk/l10n-kf{5,6}/{...}
  // but each parent directory needs to be a working copy, ie. checked out.
  // To checkout each parent directory, there are only 3 options:
  // - Set depth to infinity, which is too much
  // - Set depth to immediates, which includes irrelevant folders and files
  // - Set depth to files, which has irrelevant files but is the least bad
  // So this is setting the directory.
  console.log(`Setting up parent paths...`);
  $$("svn update --set-depth files trunk");
  $$("svn update --set-depth files branches");
  $$("svn update --set-depth files branches/stable");
  $$(
    "svn update --set-depth files",
    // Doing the product in JS makes it to pass in variables
    ...fastCartesian([
      ["trunk", "branches/stable"],
      ["l10n-kf5", "l10n-kf6"],
    ]).map((a) => a.join("/")),
  );

  checkoutLanguages([...languages]);

  console.log(`Setting up the local Git repository...`);
  $$("git init");
  console.log(`Excluding .svn from Git...`);
  mkdirSync(path.join(".git", "info"), { recursive: true });
  writeFileSync(path.join(".git", "info", "exclude"), `.svn/`);
  console.log(`Creating initial Git commit...`);
  $$("git add .");
  $$("git commit -m before");
}

/**
 * Create the Lokalize project file for `lang`.
 * Assumes we are in the main dir.
 */
function initLokalizeProject(lang?: string, reference?: string) {
  function promptLoop(message: string) {
    while (true) {
      const answer = prompt(message);
      if (typeof answer === "string") return answer;
      console.log("Please provide an answer");
    }
  }
  const targetLang =
    lang ?? promptLoop("Primary language (for Lokalize project):");
  const referenceLang =
    reference ?? promptLoop("Reference language (for Lokalize project):");

  const mailingList =
    targetLang === "zh_TW" ? "zh-l10n@lists.slat.org" : "Please fill this in";
  const languageName =
    targetLang === "zh_TW" ? "Traditional Chinese" : "Please fill this in";

  const trunkAlt = referenceLang;
  const stableAlt = `stable.${referenceLang}`;
  const trunkTarget = targetLang;
  const stableTarget = `stable.${targetLang}`;

  writeFileSync(
    path.join(trunkTarget, "index.lokalize"),
    `
[General]
AltDir=../${trunkAlt}
BranchDir=../${stableTarget}
LangCode=${targetLang}
LanguageSource=Project
PotBaseDir=../templates
PotBranchDir=../stable.templates
MailingList=${mailingList}
ProjLangTeam=${languageName} <${mailingList}>
ProjectID=kde-translation-${targetLang}
TargetLangCode=${targetLang}
[RegExps]
Markup=(<[^>]+>)+|(&[A-Za-z_:][A-Za-z0-9_\\\\.:-]*;|%[0-9n])+
`.trim(),
  );
  writeFileSync(
    path.join(stableTarget, "index.lokalize"),
    `
[General]
AltDir=../${stableAlt}
BranchDir=../${trunkTarget}
LangCode=${targetLang}
LanguageSource=Project
PotBaseDir=../stable.templates
PotBranchDir=../templates
MailingList=${mailingList}
ProjLangTeam=${languageName} <${mailingList}>
ProjectID=kde-translation-${targetLang}
TargetLangCode=${targetLang}
[RegExps]
Markup=(<[^>]+>)+|(&[A-Za-z_:][A-Za-z0-9_\\\\.:-]*;|%[0-9n])+
`.trim(),
  );
}

program
  .command("init")
  .description("Initialize a translation workspace")
  .argument(
    "[dir]",
    "Where to clone to, defaults to 'kde-translations'",
    "kde-translations",
  )
  .option(
    "--langs <languages>",
    "Which languages to clone, as language codes. Comma-separated.",
  )
  .option("--read-only", "the --limit argument of svn log")
  .action((dir: string, opts: { langs?: string; readOnly?: boolean }) => {
    const languages = opts?.langs
      ? opts.langs.split(",").map((x) => x.trim())
      : [];
    if (languages.length < 1) {
      console.log(`Please specify one or more languages with --langs`);
      process.exit(1);
    }
    if (existsSync(dir)) {
      console.log(`${dir} already exists.`);
      process.exit(1);
    }
    // kde-translations/svn
    setupSvnCheckout(path.join(dir, "svn"), opts.readOnly, languages);
    // kde-translations/l10n-templates
    process.chdir(dir);
    const $$ = runcmd({ showcmd: true });
    $$(
      "git clone --depth 1 https://invent.kde.org/localization/l10n-templates",
    );

    console.log("Creating Lokalize project structure...");
    // kde-translations/{"","stable."}<lang>/{kf5,kf6}
    // We do {"","stable."}/<lang>/{kf5,kf6} because Lokalize finds files based
    // on the directory hierarchy, and we want to see kf5 and kf6 at once, but
    // we don't want to see trunk and stable at once. Trunk and stable should
    // instead be managed by opening one of them at a time, then using
    // alternative translations to automatically synchronize them over.
    for (const lang of languages) {
      for (const prefix of ["", "stable."]) {
        const variant = `${prefix}${lang}`;
        mkdirSync(variant);
        for (const branch of ["kf5", "kf6"]) {
          symlinkSync(
            // this is what's written into the symlink, so it's relative to the
            // symlink itself
            path.join("..", "svn", "trunk", `l10n-${branch}`, lang),
            path.join(variant, branch),
          );
        }
      }
    }

    // kde-translations/{"","stable."}templates/{kf5,kf6}
    mkdirSync("stable.templates");
    symlinkSync(
      path.join("..", "l10n-templates", "stable5"),
      path.join("stable.templates", "kf5"),
    );
    symlinkSync(
      path.join("..", "l10n-templates", "stable6"),
      path.join("stable.templates", "kf6"),
    );
    mkdirSync("templates");
    symlinkSync(
      path.join("..", "l10n-templates", "trunk5"),
      path.join("templates", "kf5"),
    );
    symlinkSync(
      path.join("..", "l10n-templates", "trunk6"),
      path.join("templates", "kf6"),
    );

    initLokalizeProject();

    console.log(`Checkout done.
The Lokalize project can be seen in ${dir}/<language>/index.lokalize.
The filled-in metadata most likely needs updating.

Use ${chalk.yellow("k-kdesvn update")} at ${dir}/svn to do an svn update followed by adding the new changes into one local git commit.`);
  });

program
  .command("check")
  .description("Do an msgfmt check for all po files")
  .action(cmdCheck);

program
  .command("update")
  .description("svn update; git add .; git commit")
  .action(cmdUpdate);

program
  .command("msg")
  .summary("Copy latest Git commit message into the clipboard.")
  .description(
    `Copy latest Git commit message into the clipboard.
Assumes xclip is installed and working.
`,
  )
  .action(cmdMsg);

program
  .command("pocount")
  .summary("Show stats of the current folder with pocount.")
  .action(() => {
    runcmd({ shell: true, nothrow: true, showcmd: true })(
      "fd -L -e po -X pocount | grep TOTAL -A 8 | grep -v TOTAL",
    );
  });

program
  .command("log")
  .summary("Like `svn log` but exclude revisions from scripty.")
  .description(
    `Like \`svn log\` but exclude revisions from scripty.

Example:
  Fetch the last 100 revisions then exclude scripty changes:
    k-gitsvn log -l 100
  Fetch revisions since 2025-01-01 then exclude scripty changes:
    k-gitsvn log --since "2025-01-01"
  Fetch the last 100 revisions excluding authors "a" and "b":
    k-gitsvn log --exclude "a,b" # scripty is included in this case`,
  )
  .option("-l, --limit <n>", "the --limit argument of svn log")
  .option("--since <date>", "Provide log from <date> to HEAD.")
  .option(
    "--exclude <authors...>",
    'Exclude a different set of authors. Defaults to ["scripty"].',
  )
  .option(
    "--only <authors...>",
    "Show only revisions from these authors. Has higher priority than --exclude.",
  )
  .option("--highlight <authors...>", "Highlight these authors.")
  .addOption(
    new Option(
      `--msg-format <${ArgLogMsgFormat.options.join("|")}>`,
      "How to show messages. Defaults to full messages.",
    )
      .choices(ArgLogMsgFormat.options)
      .default("full"),
  )
  .addOption(
    new Option(
      `--sort <${ArgLogSort.options}>`,
      "How to sort messages. Defaults to new to old.",
    )
      .default("new-first")
      .choices(ArgLogSort.options),
  )
  .action(cmdLog);

/**
 * Pull from svn and do a Git commit for the latest state.
 * Assumes the repository is already set up, namely that .svn is already
 * excluded by Git.
 */
function cmdUpdate() {
  runcmd({ shell: true, nothrow: true, showcmd: true })(
    "svn update && git add . && git commit -m before",
  );
}

/**
 * Show and copy message of the latest commit from Git.
 * The plumbing from this to svn commit is not yet done. For now just, uh, run
 * the command yourself and paste it in.
 */
function cmdMsg() {
  const message = runcmd({ quiet: true })(
    "git show --format=%B --no-patch HEAD",
  ).stdout.trim();
  // -l <n> specifies how many X requests before it exits. This is a quirk
  // with how the clipboard in X is by default a communication channel between
  // apps (copy source needs to be active to paste).
  // Just, uh, try a few times. :shrug:
  // This is my own script, it doesn't have to be super reliable.
  runcmd({ input: message + "\n" })(
    "xclip -silent -r -l 5 -selection clipboard",
  );
  console.log("Copied!");
}

function cmdCheck() {
  runcmd({
    showcmd: true,
    nothrow: true,
  })(`fd -e po -x msgfmt -o /dev/null --check-format`);
}

async function cmdLog(opts?: {
  /** --limit as passed to svn log. Defaults to 100 if --since is not
   * provided, undefined if it is. */
  limit?: string;
  /** List changes from this date to HEAD. */
  since?: string;
  /** Exclude these authors. Comma-separated but can also be an array. Defaults to "scripty". */
  exclude?: string[];
  /** Show only these authors. Higher priority than exclude. Comma-separated but can also be an array. Defaults to "scripty". */
  only?: string[];
  /** Highlight these authors. Comma-separated but can also be an array. Defaults to highlighting no one. */
  highlight?: string[];
  /** How to sort log entries. Undefined means return whatever svn log returns. */
  sort?: string;
  /** How to show commit messages. */
  msgFormat?: string;
}) {
  const stream = process.stdout.isTTY
    ? spawn("/usr/bin/less", ["-R"], {
        stdio: ["pipe", "inherit", "inherit"],
      }).stdin
    : process.stdout;
  const revision = opts?.since && `{${opts.since}}:HEAD`;
  // When --since is provided, --limit should act like no limit by default
  // but when --since is not provided, --limit should have a default of 100
  const limit = opts?.limit ?? (revision ? undefined : "100");
  // Specify defaults in one place.
  const sort = ArgLogSort.parse(opts?.sort ?? "new-first");
  const msgFormat = ArgLogMsgFormat.parse(opts?.msgFormat ?? "full");
  const sep = chalk.grey("-".repeat(72));
  const excludeSet = new Set(parseCommaSeparated(opts?.exclude, ["scripty"]));
  const onlySet = new Set(parseCommaSeparated(opts?.only, []));
  const highlightedSet = new Set(parseCommaSeparated(opts?.highlight, []));
  const authors = new Map<string, number>();

  stream.write(
    `--limit: ${limit ?? "unspecified"}
--revision: ${revision ?? "unspecified"}
Sort: ${sort ?? "unspecified"}
Excluded authors: ${[...excludeSet].join(", ")}
"Only" authors: ${[...onlySet].join(", ")}
Highlighted authors: ${[...highlightedSet].join(", ")}
` + "\n",
  );

  console.error("Fetching log messages from remote...");
  const logentries = await fetchLogEntries({
    limit,
    revision,
    sort,
  });

  for (const entry of logentries) {
    authors.set(entry.author, (authors.get(entry.author) || 0) + 1);
    // When --only is specified, exclude everyone not on that list
    if (onlySet.size !== 0 && !onlySet.has(entry.author)) continue;
    // excluded and not in the only list -> skip the entry
    // excluded but in the only list -> keep the entry
    // because we want --only to have higher priority
    if (excludeSet.has(entry.author) && !onlySet.has(entry.author)) continue;
    const moment = entry.date;
    stream.write(sep);
    stream.write("\n");
    const revision = entry["@_revision"];
    stream.write(
      `r${chalk.blue(
        link(
          revision,
          `https://websvn.kde.org/?view=revision&revision=${revision}`,
        ),
      )} ${chalk.grey("|")} ${
        highlightedSet.has(entry.author)
          ? chalk.yellow.bold(entry.author)
          : chalk.yellow(entry.author)
      } ${chalk.grey("|")} ${formatISO(moment)}`,
    );
    stream.write("\n");
    if (msgFormat === "full") {
      // highlight first line in bold
      const newlinePos = entry.msg.indexOf("\n");
      if (newlinePos === -1) {
        stream.write(chalk.bold(entry.msg) + "\n");
      } else {
        stream.write(chalk.bold(entry.msg.substring(0, newlinePos)));
        stream.write(entry.msg.substring(newlinePos));
        stream.write("\n");
      }
    } else if (msgFormat === "one-line") {
      const newlinePos = entry.msg.indexOf("\n");
      if (newlinePos === -1) {
        stream.write(entry.msg);
        stream.write("\n");
      } else {
        stream.write(entry.msg.substring(0, newlinePos));
        stream.write("\n");
      }
    }
  }
  stream.write(sep);
  stream.write("\n\n");
  stream.write(`Stats:\n`);
  stream.write(
    JSON.stringify(
      Object.fromEntries([...authors].sort((a, b) => (a[1] < b[1] ? 1 : -1))),
      null,
      2,
    ),
  );
  stream.write(`\n`);
  if (stream !== process.stdout) {
    stream.end();
  }
}

// Ignore top level errors
// If we pipe output to less then quit it without viewing the whole
// thing, the pager doesn't consume the entire pipe, which leads to a
// BrokenPipe error.
// This is the overkill but fast way to get rid of it.
program.parseAsync().catch(() => {});
