#!/usr/bin/env -S deno run -A
// -*- mode: typescript; -*-
/** Commands for managing a local kdesvn repository checkout. */
// vim: ft=typescript

import {
  mkdirSync,
  writeFileSync,
  readFileSync,
  existsSync,
  rmSync,
} from "node:fs";
import { spawn } from "node:child_process";
import * as process from "node:process";
import path from "node:path";

// Fancy name for "every combination" that Shell exposes in the {a,b}{c,d}
// wildcard syntax.
import fastCartesian from "npm:fast-cartesian";
import { Chalk } from "npm:chalk";

import { program, Option } from "npm:@commander-js/extra-typings";

const chalk = new Chalk({
  // Force colors on even if we're piping to another program
  // The main program we're piping to is `less -R`. We just want paging for the
  // same output we'd get in the terminal normally.
  level: 3,
});

import { link } from "npm:ansi-escapes";

import {
  parseCommaSeparated,
  formatISO,
  fetchLogEntries,
  ArgLogMsgFormat,
  ArgLogSort,
} from "./utils.ts";
import { runcmd } from "./runcmd.ts";

program.description(`Commands for managing a local checkout of an svn repository with git.

The Git repository is only here locally, and is used for local diff checking.`);

/**
 * Check out `languages` for the current repository.
 * Assumes current directory is the top level of the svn working copy.
 */
function checkoutLanguages(languages: string[]) {
  // Valid team names. We read them here because they've only become
  // available here.
  const teamnames = readFileSync(`trunk/l10n-kf6/teamnames`, {
    encoding: "utf-8",
  })
    .split("\n")
    .map((x) => {
      const trimmed = x.trim();
      return trimmed.length === 0 || trimmed.startsWith("#")
        ? undefined
        : trimmed.split("=")[0];
    })
    .filter((x) => typeof x === "string");
  const invalidLanguages = [
    ...new Set(languages).difference(new Set(...teamnames)),
  ];
  if (invalidLanguages.length > 0) {
    console.log(
      invalidLanguages.length === 1
        ? `Invalid language code provided: ${invalidLanguages}`
        : `Invalid language codes provided: ${invalidLanguages}`,
    );
    process.exit(1);
  }
  console.log(`Setting up language paths...`);
  runcmd()(
    "svn update --set-depth infinity",
    ...fastCartesian([
      ["trunk", "branches/stable"],
      ["l10n-kf5", "l10n-kf6"],
      languages,
    ]).map((a) => a.join("/")),
  );
}

program
  .command("setup-lokalize")
  .description('Set up a "workspace" for Lokalize')
  .argument("<dir>", "Where to set it up in")
  .action((dir: string) => {
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }
    console.log(
      `Not yet implemented. Just make sure things are laid out like this undir <dir>:

<lang>/{kf5,kf6}:
  Trunk translations for the language
    symlinks to ~/kde-svn/branches/stable/l10n-{kf5,kf6}/<lang>

stable.<lang>/{kf5,kf6}:
  Stable translations for the language;
    symlinks to ~/kde-svn/trunk/l10n-{kf5,kf6}/<lang>

l10n-templates:
  A checkout of https://invent.kde.org/localization/l10n-templates

templates/{kf5,kf6}:
  Trunk templates, symlinks to l10n-templates/{trunk5,trunk6}

stable.templates/{kf5,kf6}:
  Stable templates, symlinks to l10n-templates/{stable5,stable6}

<lang>/index.lokalize:
  [General]
  AltDir=../<reference language>
  BranchDir=../stable.<lang>
  LangCode=<lang>
  LanguageSource=Project
  PotBaseDir=../templates
  PotBranchDir=../stable.templates
  # Like "zh-l10n@lists.slat.org"
  MailingList=...
  # Like "Traditional Chinese <zh-l10n@lists.slat.org>"
  ProjLangTeam=...
  ProjectID=kde-translation-<lang>
  TargetLangCode=<lang>
  [RegExps]
  Markup=(<[^>]+>)+|(&[A-Za-z_:][A-Za-z0-9_\\\\.:-]*;|%[0-9n])+
`,
    );
  });

program
  .command("checkout-language")
  .description("Add languages to the current working copy.")
  .argument(
    "<langs>",
    "Which languages to clone, as language codes. Comma-separated.",
  )
  .action((langs: string) => {
    const languages = langs.split(",").map((x) => x.trim());
    if (languages.length < 1) {
      console.log(`Please specify one or more languages`);
      process.exit(1);
    }

    const toplevelResult = runcmd({ quiet: true, nothrow: true })(
      "git rev-parse --show-toplevel",
    );
    if (toplevelResult.status !== 0) {
      console.log(`The current directory is not in a Git repository.`);
    }
    const toplevel = toplevelResult.stdout.trim();
    process.chdir(toplevel);

    if (!existsSync(".svn")) {
      console.log(`The current repository is not an svn working copy.`);
      process.exit(1);
    }
    checkoutLanguages(languages);
  });

program
  .command("clone")
  .description("Clone/checkout a new working copy")
  .argument("[dir]", "Where to clone to, defaults to 'kde-svn'", "kde-svn")
  .option(
    "--langs <languages>",
    "Which languages to clone, as language codes. Comma-separated.",
  )
  .option("--read-only", "the --limit argument of svn log")
  .option("--force", "Clear `dir` if it already exists")
  .action(
    (
      dir: string,
      opts: { langs?: string; readOnly?: boolean; force?: boolean },
    ) => {
      const languages = opts?.langs
        ? opts.langs.split(",").map((x) => x.trim())
        : [];
      if (languages.length < 1) {
        console.log(`Please specify one or more languages with --langs`);
        process.exit(1);
      }
      if (existsSync(dir)) {
        if (opts.force) {
          process.stdout.write(`Deleting ${dir} before cloning into it...`);
          rmSync(dir, { recursive: true, force: true });
          process.stdout.write(`done\n`);
        } else {
          console.log(`${dir} already exists.`);
          process.exit(1);
        }
      }
      const repoUrl = opts.readOnly
        ? "svn://anonsvn.kde.org/home/kde/"
        : "svn+ssh://svn@svn.kde.org/home/kde/";
      console.log(
        opts.readOnly
          ? `Checking out the read-only KDE subversion repository into ${dir}...`
          : `Checking out the read-write KDE subversion repository into ${dir}...`,
      );
      const $$ = runcmd({ showcmd: true });
      $$("svn checkout --depth=empty", repoUrl, dir);
      process.chdir(dir);
      // The goal:
      //   svn update --set-depth infinity branches/stable/l10n-kf{5,6}/{...}
      //   svn update --set-depth infinity trunk/l10n-kf{5,6}/{...}
      // but each parent directory needs to be a working copy, ie. checked out.
      // To checkout each parent directory, there are only 3 options:
      // - Set depth to infinity, which is too much
      // - Set depth to immediates, which includes irrelevant folders and files
      // - Set depth to files, which has irrelevant files but is the least bad
      // So this is setting the directory.
      console.log(`Setting up parent paths...`);
      $$("svn update --set-depth files trunk");
      $$("svn update --set-depth files branches");
      $$("svn update --set-depth files branches/stable");
      $$(
        "svn update --set-depth files",
        // Doing the product in JS makes it to pass in variables
        ...fastCartesian([
          ["trunk", "branches/stable"],
          ["l10n-kf5", "l10n-kf6"],
        ]).map((a) => a.join("/")),
      );

      checkoutLanguages([...languages]);

      console.log(`Setting up the local Git repository...`);
      $$("git init");
      console.log(`Excluding .svn from Git...`);
      mkdirSync(path.join(".git", "info"), { recursive: true });
      writeFileSync(path.join(".git", "info", "exclude"), `.svn/`);
      console.log(`Creating initial Git commit...`);
      $$("git add .");
      $$("git commit -m before");
      console.log(`Checkout done.
While at the root of the working copy:
  Use ${chalk.yellow("k-kdesvn checkout-language <languages>")} to add more languages.
  Use ${chalk.yellow("k-kdesvn update")} to do an svn update followed by adding the new changes into one local git commit.`);
    },
  );

program
  .command("check")
  .description("Do an msgfmt check for all po files")
  .action(cmdCheck);

program
  .command("update")
  .description("svn update; git add .; git commit")
  .action(cmdUpdate);

program
  .command("msg")
  .summary("Copy latest Git commit message into the clipboard.")
  .description(
    `Copy latest Git commit message into the clipboard.
Assumes xclip is installed and working.
`,
  )
  .action(cmdMsg);

program
  .command("pocount")
  .summary("Show stats of the current folder with pocount.")
  .action(() => {
    runcmd({ shell: true, nothrow: true, showcmd: true })(
      "fd -L -e po -X pocount | grep TOTAL -A 8 | grep -v TOTAL",
    );
  });

program
  .command("log")
  .summary("Like `svn log` but exclude revisions from scripty.")
  .description(
    `Like \`svn log\` but exclude revisions from scripty.

Example:
  Fetch the last 100 revisions then exclude scripty changes:
    k-gitsvn log -l 100
  Fetch revisions since 2025-01-01 then exclude scripty changes:
    k-gitsvn log --since "2025-01-01"
  Fetch the last 100 revisions excluding authors "a" and "b":
    k-gitsvn log --exclude "a,b" # scripty is included in this case`,
  )
  .option("-l, --limit <n>", "the --limit argument of svn log")
  .option("--since <date>", "Provide log from <date> to HEAD.")
  .option(
    "--exclude <authors...>",
    'Exclude a different set of authors. Defaults to ["scripty"].',
  )
  .option(
    "--only <authors...>",
    "Show only revisions from these authors. Has higher priority than --exclude.",
  )
  .option(
    "--unhighlighted <authors...>",
    'Highlight everyone except these. Defaults to ["moonlight"].',
  )
  .addOption(
    new Option(
      `--msg-format <${ArgLogMsgFormat.options.join("|")}>`,
      "How to show messages. Defaults to full messages.",
    )
      .choices(ArgLogMsgFormat.options)
      .default("full"),
  )
  .addOption(
    new Option(
      `--sort <${ArgLogSort.options}>`,
      "How to sort messages. Defaults to new to old.",
    )
      .default("new-first")
      .choices(ArgLogSort.options),
  )
  .action(cmdLog);

/**
 * Pull from svn and do a Git commit for the latest state.
 * Assumes the repository is already set up, namely that .svn is already
 * excluded by Git.
 */
function cmdUpdate() {
  runcmd({ shell: true, nothrow: true, showcmd: true })(
    "svn update; git add .; git commit -m before",
  );
}

/**
 * Show and copy message of the latest commit from Git.
 * The plumbing from this to svn commit is not yet done. For now just, uh, run
 * the command yourself and paste it in.
 */
function cmdMsg() {
  const message = runcmd({ quiet: true })(
    "git show --format=%B --no-patch HEAD",
  ).stdout.trim();
  // -l <n> specifies how many X requests before it exits. This is a quirk
  // with how the clipboard in X is by default a communication channel between
  // apps (copy source needs to be active to paste).
  // Just, uh, try a few times. :shrug:
  // This is my own script, it doesn't have to be super reliable.
  runcmd({ input: message + "\n" })(
    "xclip -silent -r -l 5 -selection clipboard",
  );
  console.log("Copied!");
}

function cmdCheck() {
  runcmd({
    showcmd: true,
    nothrow: true,
  })(`fd -e po -x msgfmt -o /dev/null --check-format`);
}

async function cmdLog(opts?: {
  /** --limit as passed to svn log. Defaults to 100 if --since is not
   * provided, undefined if it is. */
  limit?: string;
  /** List changes from this date to HEAD. */
  since?: string;
  /** Exclude these authors. Comma-separated but can also be an array. Defaults to "scripty". */
  exclude?: string[];
  /** Show only these authors. Higher priority than exclude. Comma-separated but can also be an array. Defaults to "scripty". */
  only?: string[];
  /** Highlight all authors except these. Comma-separated but can also be an array. Defaults to "moonlight". */
  unhighlighted?: string[];
  /** How to sort log entries. Undefined means return whatever svn log returns. */
  sort?: string;
  /** How to show commit messages. */
  msgFormat?: string;
}) {
  const stream = process.stdout.isTTY
    ? spawn("/usr/bin/less", ["-R"], {
        stdio: ["pipe", "inherit", "inherit"],
      }).stdin
    : process.stdout;
  const revision = opts?.since && `{${opts.since}}:HEAD`;
  // When --since is provided, --limit should act like no limit by default
  // but when --since is not provided, --limit should have a default of 100
  const limit = opts?.limit ?? (revision ? undefined : "100");
  // Specify defaults in one place.
  const sort = ArgLogSort.parse(opts?.sort ?? "new-first");
  const msgFormat = ArgLogMsgFormat.parse(opts?.msgFormat ?? "full");
  const sep = chalk.grey("-".repeat(72));
  const excludeSet = new Set(parseCommaSeparated(opts?.exclude, ["scripty"]));
  const onlySet = new Set(parseCommaSeparated(opts?.only, []));
  const unhighlightedSet = new Set(
    parseCommaSeparated(opts?.unhighlighted, ["moonlight"]),
  );
  const authors = new Map<string, number>();

  stream.write(
    `--limit: ${limit ?? "unspecified"}
--revision: ${revision ?? "unspecified"}
Sort: ${sort ?? "unspecified"}
Excluded authors: ${[...excludeSet].join(", ")}
"Only" authors: ${[...onlySet].join(", ")}
Unhighlighted authors: ${[...unhighlightedSet].join(", ")}
` + "\n",
  );

  console.error("Fetching log messages from remote...");
  const logentries = await fetchLogEntries({
    limit,
    revision,
    sort,
  });

  for (const entry of logentries) {
    authors.set(entry.author, (authors.get(entry.author) || 0) + 1);
    // When --only is specified, exclude everyone not on that list
    if (onlySet.size !== 0 && !onlySet.has(entry.author)) continue;
    // excluded and not in the only list -> skip the entry
    // excluded but in the only list -> keep the entry
    // because we want --only to have higher priority
    if (excludeSet.has(entry.author) && !onlySet.has(entry.author)) continue;
    const moment = entry.date;
    stream.write(sep);
    stream.write("\n");
    const revision = entry["@_revision"];
    stream.write(
      `r${link(
        revision,
        `https://websvn.kde.org/?view=revision&revision=${revision}`,
      )} ${chalk.grey("|")} ${
        unhighlightedSet.has(entry.author)
          ? chalk.grey(entry.author)
          : chalk.yellow(entry.author)
      } ${chalk.grey("|")} ${formatISO(moment)}`,
    );
    stream.write("\n");
    if (msgFormat === "full") {
      // highlight first line in bold
      const newlinePos = entry.msg.indexOf("\n");
      if (newlinePos === -1) {
        stream.write(chalk.bold(entry.msg) + "\n");
      } else {
        stream.write(chalk.bold(entry.msg.substring(0, newlinePos)));
        stream.write(entry.msg.substring(newlinePos));
        stream.write("\n");
      }
    } else if (msgFormat === "one-line") {
      const newlinePos = entry.msg.indexOf("\n");
      if (newlinePos === -1) {
        stream.write(entry.msg);
        stream.write("\n");
      } else {
        stream.write(entry.msg.substring(0, newlinePos));
        stream.write("\n");
      }
    }
  }
  stream.write(sep);
  stream.write("\n\n");
  stream.write(`Stats:\n`);
  stream.write(
    JSON.stringify(
      Object.fromEntries([...authors].sort((a, b) => (a[1] < b[1] ? 1 : -1))),
      null,
      2,
    ),
  );
  stream.write(`\n`);
  if (stream !== process.stdout) {
    stream.end();
  }
}

// Ignore top level errors
// If we pipe output to less then quit it without viewing the whole
// thing, the pager doesn't consume the entire pipe, which leads to a
// BrokenPipe error.
// This is the overkill but fast way to get rid of it.
program.parseAsync().catch(() => {});
