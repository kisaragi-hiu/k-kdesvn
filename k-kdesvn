#!/usr/bin/env -S deno run -A
// -*- mode: typescript; -*-
/** Commands for managing a local kdesvn repository checkout. */
// vim: ft=typescript

import { mkdirSync, writeFileSync } from "node:fs";
import { spawn } from "node:child_process";
import * as process from "node:process";
import path from "node:path";
import { Console } from "node:console";

import { $, chalk } from "npm:zx";
import { program, Option } from "npm:commander";

// Force colors on even if we're piping to another program
// The main program we're piping to is `less -R`. We just want paging for the
// same output we'd get in the terminal normally.
chalk.level = 3;

import { link } from "npm:ansi-escapes";

import {
  formatISO,
  fetchLogEntries,
  ArgLogMsgFormat,
  ArgLogSort,
} from "./utils.ts";

program.description(`Commands for managing a local checkout of an svn repository with git.

The Git repository is only here locally, and is used for local diff checking.`);

program
  .command("setup")
  .description("Make sure .svn is ignored")
  .action(cmdSetup);

program
  .command("check")
  .description("Do an msgfmt check for all po files")
  .action(cmdCheck);

program
  .command("update")
  .description("svn update; git add .; git commit")
  .action(cmdUpdate);

program
  .command("msg")
  .summary("Copy latest Git commit message into the clipboard.")
  .description(
    `Copy latest Git commit message into the clipboard.
Assumes xclip is installed and working.
`,
  )
  .action(cmdMsg);

program
  .command("pocount")
  .summary("Show stats of the current folder with pocount.")
  .action(async () => {
    await $({
      verbose: true,
      nothrow: true,
    })`fd -L -e po -X pocount | grep TOTAL -A 8 | grep -v TOTAL`;
  });

program
  .command("log")
  .summary("Like `svn log` but exclude revisions from scripty.")
  .description(
    `Like \`svn log\` but exclude revisions from scripty.

Example:
  Fetch the last 100 revisions then exclude scripty changes:
    k-gitsvn log -l 100
  Fetch revisions since 2025-01-01 then exclude scripty changes:
    k-gitsvn log --since "2025-01-01"
  Fetch the last 100 revisions excluding authors "a" and "b":
    k-gitsvn log --exclude "a,b" # scripty is included in this case`,
  )
  .option("-l, --limit <n>", "the --limit argument of svn log")
  .option("--since <date>", "Provide log from <date> to HEAD.")
  .option(
    "--exclude <authors...>",
    'Exclude a different set of authors. Defaults to ["scripty"].',
  )
  .option(
    "--unhighlighted <authors...>",
    'Highlight everyone except these. Defaults to ["moonlight"].',
  )
  .addOption(
    new Option(
      `--msg-format <${ArgLogMsgFormat.options.join("|")}>`,
      "How to show messages. Defaults to full messages.",
    )
      .choices(ArgLogMsgFormat.options)
      .default("full"),
  )
  .addOption(
    new Option(
      `--sort <${ArgLogSort.options}>`,
      "How to sort messages. Defaults to new to old.",
    )
      .default("new-first")
      .choices(ArgLogSort.options),
  )
  .action(cmdLog);

/** Ensure the repository is as expected. */
async function cmdSetup() {
  const toplevel = (await $`git rev-parse --show-toplevel`.text()).trim();
  const dotSvnNotExcluded = (
    await $`cd ${toplevel}; git status -s`.text()
  ).includes(".svn");
  if (dotSvnNotExcluded) {
    console.log(".svn doesn't seem excluded. Excluding locally.");
    mkdirSync(path.join(toplevel, ".git", "info"), { recursive: true });
    writeFileSync(path.join(toplevel, ".git", "info", "exclude"), `.svn/`);
  }
}

/**
 * Pull from svn and do a Git commit for the latest state.
 * Assumes the repository is already set up, namely that .svn is already
 * excluded by Git.
 */
async function cmdUpdate() {
  await $({
    verbose: true,
    nothrow: true,
  })`svn update; git add .; git commit -m before`;
}

/**
 * Show and copy message of the latest commit from Git.
 * The plumbing from this to svn commit is not yet done. For now just, uh, run
 * the command yourself and paste it in.
 */
async function cmdMsg() {
  const message = (
    await $`git show --format="%B" --no-patch HEAD`.text()
  ).trim();
  console.log(message);
  // -l <n> specifies how many X requests before it exits. This is a quirk
  // with how the clipboard in X is by default a communication channel between
  // apps (copy source needs to be active to paste).
  // -l 1 should allow eg. the KDE clipboard to take ownership of it and then
  // for xclip to exit, but that for some reason doesn't work. -l 2 works. :shrug:
  // This is my own script, it doesn't have to be super reliable.
  await $({
    input: message + "\n",
  })`xclip -silent -r -l 2 -selection clipboard`;
}

async function cmdCheck() {
  await $({
    verbose: true,
    nothrow: true,
  })`fd '\.po$' -x msgfmt -o /dev/null --check-format`;
}

async function cmdLog(opts?: {
  /** --limit as passed to svn log. Defaults to 100 if --since is not
   * provided, undefined if it is. */
  limit?: string;
  /** List changes from this date to HEAD. */
  since?: string;
  /** Exclude these authors. Comma-separated. Defaults to "scripty". */
  exclude?: string;
  /** Highlight all authors except these. Comma-separated. Defaults to "moonlight". */
  unhighlighted?: string;
  /** How to sort log entries. Undefined means return whatever svn log returns. */
  sort?: string;
  /** How to show commit messages. */
  msgFormat?: string;
}) {
  const subprocess = spawn("/usr/bin/less", ["-R"], {
    stdio: ["pipe", "inherit", "inherit"],
  });
  // I would use
  //   const stream = process.stdout.isTTY ? subprocess.stdin : process.stdout;
  // but Deno reports stream.write() as an error in that case for some reason.
  // Also, console.log accepts all kinds of objects, which is convenient.
  const consol = process.stdout.isTTY
    ? new Console({ stdout: subprocess.stdin, colorMode: true })
    : console;
  const revision = opts?.since && `{${opts.since}}:HEAD`;
  // When --since is provided, --limit should act like no limit by default
  // but when --since is not provided, --limit should have a default of 100
  const limit = opts?.limit ?? (revision ? undefined : "100");
  // Specify defaults in one place.
  const sort = ArgLogSort.parse(opts?.sort ?? "new-first");
  const msgFormat = ArgLogMsgFormat.parse(opts?.msgFormat ?? "full");
  const sep = "-".repeat(72);
  const excludeSet = new Set(
    // We have to use an explicit check against undefined, because the
    // empty string is falsy.
    // We want an empty string to take the latter case and result in an empty
    // excludes list instead of using the fallback.
    opts?.exclude === undefined ? ["scripty"] : opts?.exclude.split(","),
  );
  const unhighlightedSet = new Set(
    opts?.unhighlighted === undefined
      ? ["moonlight"]
      : opts?.unhighlighted.split(","),
  );
  const authors = new Map<string, number>();

  consol.log(`--limit: ${limit ?? "unspecified"}
--revision: ${revision ?? "unspecified"}
Sort: ${sort ?? "unspecified"}
Excluded authors: ${[...excludeSet].join(", ")}
Unhighlighted authors: ${[...unhighlightedSet].join(", ")}
`);

  consol.error("Fetching log messages from remote...");
  const logentries = await fetchLogEntries({
    limit,
    revision,
    sort,
  });

  for (const entry of logentries) {
    authors.set(entry.author, (authors.get(entry.author) || 0) + 1);
    if (excludeSet.has(entry.author)) continue;
    const moment = entry.date;
    consol.log(sep);
    const revision = entry["@_revision"];
    consol.log(
      `r${link(
        revision,
        `https://websvn.kde.org/?view=revision&revision=${revision}`,
      )} | ${
        unhighlightedSet.has(entry.author)
          ? entry.author
          : chalk.yellow(entry.author)
      } | ${formatISO(moment)}`,
    );
    if (msgFormat === "full") {
      consol.log(entry.msg);
    } else if (msgFormat === "one-line") {
      const newlinePos = entry.msg.indexOf("\n");
      if (newlinePos === -1) {
        consol.log(entry.msg);
      } else {
        consol.log(entry.msg.substring(0, newlinePos));
      }
    }
  }
  consol.log(sep);
  consol.log(`
Stats:`);
  consol.log(
    Object.fromEntries([...authors].sort((a, b) => (a[1] < b[1] ? 1 : -1))),
  );
  subprocess.stdin.end();
}

// Ignore top level errors
// If we pipe output to less then quit it without viewing the whole
// thing, the pager doesn't consume the entire pipe, which leads to a
// BrokenPipe error.
// This is the overkill but fast way to get rid of it.
program.parseAsync().catch(() => {});
